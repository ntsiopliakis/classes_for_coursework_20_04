###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         20/Apr/2021  18:22:04
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\FreeRtos\event_groups.c
#    Command line =
#        -f C:\Users\D13C~1\AppData\Local\Temp\EW6C03.tmp
#        (C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\FreeRtos\event_groups.c
#        -lC
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Debug\List
#        -lA
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Debug\List
#        -o
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\wrapper\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\wrapper\FreeRtos\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\FreeRtos\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\FreeRtos\include\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\FreeRtos\portable\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\FreeRtos\portable\Common\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\FreeRtos\portable\IAR\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\FreeRtos\portable\IAR\ARM_CM4F\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\FreeRtos\portable\MemMang\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\MyTasks\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Common\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\CMSIS\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Application\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Application\Diagnostic\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\AHardware\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\AHardware\GpioPort\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\AHardware\IrqController\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\..\CortexLib\AbstractHardware\Pin\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\..\CortexLib\AbstractHardware\Registers\STM32F411\FieldValues\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\..\CortexLib\AbstractHardware\Registers\STM32F411\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\..\CortexLib\AbstractHardware\Registers\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\..\CortexLib\AbstractHardware\Port\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\..\CortexLib\AbstractHardware\Atomic\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\..\CortexLib\Common\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\..\CortexLib\Common\Singleton\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\..\CortexLib\Common\RomObject\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\AHardware\Port\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\AHardware\Pin\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Application\Button\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Application\Led\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Application\Measurement\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\AHardware\USART\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\..\CortexLib\AbstractHardware\Registers\CortexM4\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\..\CortexLib\AbstractHardware\Registers\CortexM4\FieldValues\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\AHardware\SPI\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\AHardware\BME280Driver\
#        -I
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\AHardware\EPDDriver\
#        -On)
#    Locale       =  C
#    List file    =
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Debug\List\event_groups.lst
#    Object file  =
#        C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Debug\Obj\event_groups.o
#
###############################################################################

C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\Rtos\FreeRtos\event_groups.c
      1          /*
Warning[Ms014]: some characters could not be correctly encoded in
          "C:\Users\@@@@@@@@\Documents\MyIARprojects\KursovoiK_\RtosWrapper\De
          bug\List\event_groups.s", and have been replaced with '@'. The first
          such character has unicode code point 0x41d ("@")
      2              FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          
     73          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     74          all the API functions to use the MPU wrappers.  That should only be done when
     75          task.h is included from an application file. */
     76          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     77          
     78          /* FreeRTOS includes. */
     79          #include "FreeRTOS.h"
     80          #include "task.h"
     81          #include "timers.h"
     82          #include "event_groups.h"
     83          
     84          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     85          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     86          header files above, but not in this file, in order to generate the correct
     87          privileged Vs unprivileged linkage and placement. */
     88          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     89          
     90          /* The following bit fields convey control information in a task's event list
     91          item value.  It is important they don't clash with the
     92          taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
     93          #if configUSE_16_BIT_TICKS == 1
     94          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
     95          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
     96          	#define eventWAIT_FOR_ALL_BITS			0x0400U
     97          	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
     98          #else
     99          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
    100          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
    101          	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
    102          	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
    103          #endif
    104          
    105          typedef struct xEventGroupDefinition
    106          {
    107          	EventBits_t uxEventBits;
    108          	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
    109          
    110          	#if( configUSE_TRACE_FACILITY == 1 )
    111          		UBaseType_t uxEventGroupNumber;
    112          	#endif
    113          
    114          	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    115          		uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. */
    116          	#endif
    117          } EventGroup_t;
    118          
    119          /*-----------------------------------------------------------*/
    120          
    121          /*
    122           * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
    123           * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
    124           * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
    125           * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
    126           * wait condition is met if any of the bits set in uxBitsToWait for are also set
    127           * in uxCurrentEventBits.
    128           */
    129          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits ) PRIVILEGED_FUNCTION;
    130          
    131          /*-----------------------------------------------------------*/
    132          
    133          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    134          

   \                                 In section .text, align 2, keep-with-next
    135          	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer )
    136          	{
   \                     xEventGroupCreateStatic: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
    137          	EventGroup_t *pxEventBits;
    138          
    139          		/* A StaticEventGroup_t object must be provided. */
    140          		configASSERT( pxEventGroupBuffer );
    141          
    142          		/* The user has provided a statically allocated event group - use it. */
    143          		pxEventBits = ( EventGroup_t * ) pxEventGroupBuffer; /*lint !e740 EventGroup_t and StaticEventGroup_t are guaranteed to have the same size and alignment requirement - checked by configASSERT(). */
   \        0x4   0x002C             MOVS     R4,R5
    144          
    145          		if( pxEventBits != NULL )
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD004             BEQ.N    ??xEventGroupCreateStatic_0
    146          		{
    147          			pxEventBits->uxEventBits = 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x6020             STR      R0,[R4, #+0]
    148          			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
   \        0xE   0x1D20             ADDS     R0,R4,#+4
   \       0x10   0x....'....        BL       vListInitialise
    149          
    150          			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    151          			{
    152          				/* Both static and dynamic allocation can be used, so note that
    153          				this event group was created statically in case the event group
    154          				is later deleted. */
    155          				pxEventBits->ucStaticallyAllocated = pdTRUE;
    156          			}
    157          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    158          
    159          			traceEVENT_GROUP_CREATE( pxEventBits );
    160          		}
    161          		else
    162          		{
    163          			traceEVENT_GROUP_CREATE_FAILED();
    164          		}
    165          
    166          		return ( EventGroupHandle_t ) pxEventBits;
   \                     ??xEventGroupCreateStatic_0: (+1)
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    167          	}
    168          
    169          #endif /* configSUPPORT_STATIC_ALLOCATION */
    170          /*-----------------------------------------------------------*/
    171          
    172          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    173          
    174          	EventGroupHandle_t xEventGroupCreate( void )
    175          	{
    176          	EventGroup_t *pxEventBits;
    177          
    178          		/* Allocate the event group. */
    179          		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
    180          
    181          		if( pxEventBits != NULL )
    182          		{
    183          			pxEventBits->uxEventBits = 0;
    184          			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    185          
    186          			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    187          			{
    188          				/* Both static and dynamic allocation can be used, so note this
    189          				event group was allocated statically in case the event group is
    190          				later deleted. */
    191          				pxEventBits->ucStaticallyAllocated = pdFALSE;
    192          			}
    193          			#endif /* configSUPPORT_STATIC_ALLOCATION */
    194          
    195          			traceEVENT_GROUP_CREATE( pxEventBits );
    196          		}
    197          		else
    198          		{
    199          			traceEVENT_GROUP_CREATE_FAILED();
    200          		}
    201          
    202          		return ( EventGroupHandle_t ) pxEventBits;
    203          	}
    204          
    205          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    206          /*-----------------------------------------------------------*/
    207          

   \                                 In section .text, align 2, keep-with-next
    208          EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
    209          {
   \                     xEventGroupSync: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x001C             MOVS     R4,R3
    210          EventBits_t uxOriginalBitValue, uxReturn;
    211          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   \        0xC   0x46A8             MOV      R8,R5
    212          BaseType_t xAlreadyYielded;
    213          BaseType_t xTimeoutOccurred = pdFALSE;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9000             STR      R0,[SP, #+0]
    214          
    215          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    216          	configASSERT( uxBitsToWaitFor != 0 );
    217          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    218          	{
    219          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \       0x12   0x....'....        BL       xTaskGetSchedulerState
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??xEventGroupSync_0
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD101             BNE.N    ??xEventGroupSync_1
   \                     ??xEventGroupSync_0: (+1)
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xE000             B.N      ??xEventGroupSync_2
   \                     ??xEventGroupSync_1: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
    220          	}
    221          	#endif
    222          
    223          	vTaskSuspendAll();
   \                     ??xEventGroupSync_2: (+1)
   \       0x24   0x....'....        BL       vTaskSuspendAll
    224          	{
    225          		uxOriginalBitValue = pxEventBits->uxEventBits;
   \       0x28   0xF8D8 0x9000      LDR      R9,[R8, #+0]
    226          
    227          		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
   \       0x2C   0x0031             MOVS     R1,R6
   \       0x2E   0x0028             MOVS     R0,R5
   \       0x30   0x....'....        BL       xEventGroupSetBits
    228          
    229          		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \       0x34   0xEA56 0x0009      ORRS     R0,R6,R9
   \       0x38   0x4038             ANDS     R0,R7,R0
   \       0x3A   0x42B8             CMP      R0,R7
   \       0x3C   0xD109             BNE.N    ??xEventGroupSync_3
    230          		{
    231          			/* All the rendezvous bits are now set - no need to block. */
    232          			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
   \       0x3E   0xEA56 0x0A09      ORRS     R10,R6,R9
    233          
    234          			/* Rendezvous always clear the bits.  They will have been cleared
    235          			already unless this is the only task in the rendezvous. */
    236          			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0x42   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x46   0x43B8             BICS     R0,R0,R7
   \       0x48   0xF8C8 0x0000      STR      R0,[R8, #+0]
    237          
    238          			xTicksToWait = 0;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x0004             MOVS     R4,R0
   \       0x50   0xE00D             B.N      ??xEventGroupSync_4
    239          		}
    240          		else
    241          		{
    242          			if( xTicksToWait != ( TickType_t ) 0 )
   \                     ??xEventGroupSync_3: (+1)
   \       0x52   0x2C00             CMP      R4,#+0
   \       0x54   0xD009             BEQ.N    ??xEventGroupSync_5
    243          			{
    244          				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
    245          
    246          				/* Store the bits that the calling task is waiting for in the
    247          				task's event list item so the kernel knows when a match is
    248          				found.  Then enter the blocked state. */
    249          				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
   \       0x56   0x0022             MOVS     R2,R4
   \       0x58   0xF057 0x61A0      ORRS     R1,R7,#0x5000000
   \       0x5C   0xF118 0x0004      ADDS     R0,R8,#+4
   \       0x60   0x....'....        BL       vTaskPlaceOnUnorderedEventList
    250          
    251          				/* This assignment is obsolete as uxReturn will get set after
    252          				the task unblocks, but some compilers mistakenly generate a
    253          				warning about uxReturn being returned without being set if the
    254          				assignment is omitted. */
    255          				uxReturn = 0;
   \       0x64   0xF05F 0x0A00      MOVS     R10,#+0
   \       0x68   0xE001             B.N      ??xEventGroupSync_4
    256          			}
    257          			else
    258          			{
    259          				/* The rendezvous bits were not set, but no block time was
    260          				specified - just return the current event bit value. */
    261          				uxReturn = pxEventBits->uxEventBits;
   \                     ??xEventGroupSync_5: (+1)
   \       0x6A   0xF8D8 0xA000      LDR      R10,[R8, #+0]
    262          			}
    263          		}
    264          	}
    265          	xAlreadyYielded = xTaskResumeAll();
   \                     ??xEventGroupSync_4: (+1)
   \       0x6E   0x....'....        BL       xTaskResumeAll
   \       0x72   0x9001             STR      R0,[SP, #+4]
    266          
    267          	if( xTicksToWait != ( TickType_t ) 0 )
   \       0x74   0x2C00             CMP      R4,#+0
   \       0x76   0xD025             BEQ.N    ??xEventGroupSync_6
    268          	{
    269          		if( xAlreadyYielded == pdFALSE )
   \       0x78   0x9801             LDR      R0,[SP, #+4]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD107             BNE.N    ??xEventGroupSync_7
    270          		{
    271          			portYIELD_WITHIN_API();
   \       0x7E   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0x82   0x....             LDR.N    R1,??DataTable2  ;; 0xe000ed04
   \       0x84   0x6008             STR      R0,[R1, #+0]
   \       0x86   0xF3BF 0x8F4F      DSB      SY
   \       0x8A   0xF3BF 0x8F6F      ISB      SY
    272          		}
    273          		else
    274          		{
    275          			mtCOVERAGE_TEST_MARKER();
    276          		}
    277          
    278          		/* The task blocked to wait for its required bits to be set - at this
    279          		point either the required bits were set or the block time expired.  If
    280          		the required bits were set they will have been stored in the task's
    281          		event list item, and they should now be retrieved then cleared. */
    282          		uxReturn = uxTaskResetEventItemValue();
   \                     ??xEventGroupSync_7: (+1)
   \       0x8E   0x....'....        BL       uxTaskResetEventItemValue
   \       0x92   0x4683             MOV      R11,R0
    283          
    284          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   \       0x94   0xEA5F 0x108B      LSLS     R0,R11,#+6
   \       0x98   0xD411             BMI.N    ??xEventGroupSync_8
    285          		{
    286          			/* The task timed out, just return the current event bit value. */
    287          			taskENTER_CRITICAL();
   \       0x9A   0x....'....        BL       vPortEnterCritical
    288          			{
    289          				uxReturn = pxEventBits->uxEventBits;
   \       0x9E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xA2   0x4683             MOV      R11,R0
    290          
    291          				/* Although the task got here because it timed out before the
    292          				bits it was waiting for were set, it is possible that since it
    293          				unblocked another task has set the bits.  If this is the case
    294          				then it needs to clear the bits before exiting. */
    295          				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \       0xA4   0xEA17 0x000B      ANDS     R0,R7,R11
   \       0xA8   0x42B8             CMP      R0,R7
   \       0xAA   0xD104             BNE.N    ??xEventGroupSync_9
    296          				{
    297          					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0xAC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xB0   0x43B8             BICS     R0,R0,R7
   \       0xB2   0xF8C8 0x0000      STR      R0,[R8, #+0]
    298          				}
    299          				else
    300          				{
    301          					mtCOVERAGE_TEST_MARKER();
    302          				}
    303          			}
    304          			taskEXIT_CRITICAL();
   \                     ??xEventGroupSync_9: (+1)
   \       0xB6   0x....'....        BL       vPortExitCritical
    305          
    306          			xTimeoutOccurred = pdTRUE;
   \       0xBA   0x2001             MOVS     R0,#+1
   \       0xBC   0x9000             STR      R0,[SP, #+0]
    307          		}
    308          		else
    309          		{
    310          			/* The task unblocked because the bits were set. */
    311          		}
    312          
    313          		/* Control bits might be set as the task had blocked should not be
    314          		returned. */
    315          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   \                     ??xEventGroupSync_8: (+1)
   \       0xBE   0x46DA             MOV      R10,R11
   \       0xC0   0xF02A 0x4A7F      BIC      R10,R10,#0xFF000000
    316          	}
    317          
    318          	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
    319          
    320          	return uxReturn;
   \                     ??xEventGroupSync_6: (+1)
   \       0xC4   0x4650             MOV      R0,R10
   \       0xC6   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    321          }
    322          /*-----------------------------------------------------------*/
    323          

   \                                 In section .text, align 2, keep-with-next
    324          EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
    325          {
   \                     xEventGroupWaitBits: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001E             MOVS     R6,R3
   \        0xC   0x9D0E             LDR      R5,[SP, #+56]
    326          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   \        0xE   0xF8DD 0x8010      LDR      R8,[SP, #+16]
    327          EventBits_t uxReturn, uxControlBits = 0;
   \       0x12   0xF05F 0x0900      MOVS     R9,#+0
    328          BaseType_t xWaitConditionMet, xAlreadyYielded;
    329          BaseType_t xTimeoutOccurred = pdFALSE;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x9000             STR      R0,[SP, #+0]
    330          
    331          	/* Check the user is not attempting to wait on the bits used by the kernel
    332          	itself, and that at least one bit is being requested. */
    333          	configASSERT( xEventGroup );
    334          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    335          	configASSERT( uxBitsToWaitFor != 0 );
    336          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    337          	{
    338          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \       0x1A   0x....'....        BL       xTaskGetSchedulerState
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD101             BNE.N    ??xEventGroupWaitBits_0
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD101             BNE.N    ??xEventGroupWaitBits_1
   \                     ??xEventGroupWaitBits_0: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xE000             B.N      ??xEventGroupWaitBits_2
   \                     ??xEventGroupWaitBits_1: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
    339          	}
    340          	#endif
    341          
    342          	vTaskSuspendAll();
   \                     ??xEventGroupWaitBits_2: (+1)
   \       0x2C   0x....'....        BL       vTaskSuspendAll
    343          	{
    344          		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
   \       0x30   0xF8D8 0xB000      LDR      R11,[R8, #+0]
    345          
    346          		/* Check to see if the wait condition is already met or not. */
    347          		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
   \       0x34   0x0032             MOVS     R2,R6
   \       0x36   0x0039             MOVS     R1,R7
   \       0x38   0x4658             MOV      R0,R11
   \       0x3A   0x....'....        BL       prvTestWaitCondition
   \       0x3E   0x9002             STR      R0,[SP, #+8]
    348          
    349          		if( xWaitConditionMet != pdFALSE )
   \       0x40   0x9802             LDR      R0,[SP, #+8]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD00A             BEQ.N    ??xEventGroupWaitBits_3
    350          		{
    351          			/* The wait condition has already been met so there is no need to
    352          			block. */
    353          			uxReturn = uxCurrentEventBits;
   \       0x46   0x46DA             MOV      R10,R11
    354          			xTicksToWait = ( TickType_t ) 0;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x0005             MOVS     R5,R0
    355          
    356          			/* Clear the wait bits if requested to do so. */
    357          			if( xClearOnExit != pdFALSE )
   \       0x4C   0x2C00             CMP      R4,#+0
   \       0x4E   0xD01A             BEQ.N    ??xEventGroupWaitBits_4
    358          			{
    359          				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0x50   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x54   0x43B8             BICS     R0,R0,R7
   \       0x56   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \       0x5A   0xE014             B.N      ??xEventGroupWaitBits_4
    360          			}
    361          			else
    362          			{
    363          				mtCOVERAGE_TEST_MARKER();
    364          			}
    365          		}
    366          		else if( xTicksToWait == ( TickType_t ) 0 )
   \                     ??xEventGroupWaitBits_3: (+1)
   \       0x5C   0x2D00             CMP      R5,#+0
   \       0x5E   0xD101             BNE.N    ??xEventGroupWaitBits_5
    367          		{
    368          			/* The wait condition has not been met, but no block time was
    369          			specified, so just return the current value. */
    370          			uxReturn = uxCurrentEventBits;
   \       0x60   0x46DA             MOV      R10,R11
   \       0x62   0xE010             B.N      ??xEventGroupWaitBits_4
    371          		}
    372          		else
    373          		{
    374          			/* The task is going to block to wait for its required bits to be
    375          			set.  uxControlBits are used to remember the specified behaviour of
    376          			this call to xEventGroupWaitBits() - for use when the event bits
    377          			unblock the task. */
    378          			if( xClearOnExit != pdFALSE )
   \                     ??xEventGroupWaitBits_5: (+1)
   \       0x64   0x2C00             CMP      R4,#+0
   \       0x66   0xD001             BEQ.N    ??xEventGroupWaitBits_6
    379          			{
    380          				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
   \       0x68   0xF059 0x7980      ORRS     R9,R9,#0x1000000
    381          			}
    382          			else
    383          			{
    384          				mtCOVERAGE_TEST_MARKER();
    385          			}
    386          
    387          			if( xWaitForAllBits != pdFALSE )
   \                     ??xEventGroupWaitBits_6: (+1)
   \       0x6C   0x2E00             CMP      R6,#+0
   \       0x6E   0xD001             BEQ.N    ??xEventGroupWaitBits_7
    388          			{
    389          				uxControlBits |= eventWAIT_FOR_ALL_BITS;
   \       0x70   0xF059 0x6980      ORRS     R9,R9,#0x4000000
    390          			}
    391          			else
    392          			{
    393          				mtCOVERAGE_TEST_MARKER();
    394          			}
    395          
    396          			/* Store the bits that the calling task is waiting for in the
    397          			task's event list item so the kernel knows when a match is
    398          			found.  Then enter the blocked state. */
    399          			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
   \                     ??xEventGroupWaitBits_7: (+1)
   \       0x74   0x002A             MOVS     R2,R5
   \       0x76   0xEA59 0x0107      ORRS     R1,R9,R7
   \       0x7A   0xF118 0x0004      ADDS     R0,R8,#+4
   \       0x7E   0x....'....        BL       vTaskPlaceOnUnorderedEventList
    400          
    401          			/* This is obsolete as it will get set after the task unblocks, but
    402          			some compilers mistakenly generate a warning about the variable
    403          			being returned without being set if it is not done. */
    404          			uxReturn = 0;
   \       0x82   0xF05F 0x0A00      MOVS     R10,#+0
    405          
    406          			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
    407          		}
    408          	}
    409          	xAlreadyYielded = xTaskResumeAll();
   \                     ??xEventGroupWaitBits_4: (+1)
   \       0x86   0x....'....        BL       xTaskResumeAll
   \       0x8A   0x9001             STR      R0,[SP, #+4]
    410          
    411          	if( xTicksToWait != ( TickType_t ) 0 )
   \       0x8C   0x2D00             CMP      R5,#+0
   \       0x8E   0xD02A             BEQ.N    ??xEventGroupWaitBits_8
    412          	{
    413          		if( xAlreadyYielded == pdFALSE )
   \       0x90   0x9801             LDR      R0,[SP, #+4]
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD107             BNE.N    ??xEventGroupWaitBits_9
    414          		{
    415          			portYIELD_WITHIN_API();
   \       0x96   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0x9A   0x....             LDR.N    R1,??DataTable2  ;; 0xe000ed04
   \       0x9C   0x6008             STR      R0,[R1, #+0]
   \       0x9E   0xF3BF 0x8F4F      DSB      SY
   \       0xA2   0xF3BF 0x8F6F      ISB      SY
    416          		}
    417          		else
    418          		{
    419          			mtCOVERAGE_TEST_MARKER();
    420          		}
    421          
    422          		/* The task blocked to wait for its required bits to be set - at this
    423          		point either the required bits were set or the block time expired.  If
    424          		the required bits were set they will have been stored in the task's
    425          		event list item, and they should now be retrieved then cleared. */
    426          		uxReturn = uxTaskResetEventItemValue();
   \                     ??xEventGroupWaitBits_9: (+1)
   \       0xA6   0x....'....        BL       uxTaskResetEventItemValue
   \       0xAA   0x4683             MOV      R11,R0
    427          
    428          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   \       0xAC   0xEA5F 0x108B      LSLS     R0,R11,#+6
   \       0xB0   0xD416             BMI.N    ??xEventGroupWaitBits_10
    429          		{
    430          			taskENTER_CRITICAL();
   \       0xB2   0x....'....        BL       vPortEnterCritical
    431          			{
    432          				/* The task timed out, just return the current event bit value. */
    433          				uxReturn = pxEventBits->uxEventBits;
   \       0xB6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xBA   0x4683             MOV      R11,R0
    434          
    435          				/* It is possible that the event bits were updated between this
    436          				task leaving the Blocked state and running again. */
    437          				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
   \       0xBC   0x0032             MOVS     R2,R6
   \       0xBE   0x0039             MOVS     R1,R7
   \       0xC0   0x4658             MOV      R0,R11
   \       0xC2   0x....'....        BL       prvTestWaitCondition
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD006             BEQ.N    ??xEventGroupWaitBits_11
    438          				{
    439          					if( xClearOnExit != pdFALSE )
   \       0xCA   0x2C00             CMP      R4,#+0
   \       0xCC   0xD004             BEQ.N    ??xEventGroupWaitBits_11
    440          					{
    441          						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0xCE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xD2   0x43B8             BICS     R0,R0,R7
   \       0xD4   0xF8C8 0x0000      STR      R0,[R8, #+0]
    442          					}
    443          					else
    444          					{
    445          						mtCOVERAGE_TEST_MARKER();
    446          					}
    447          				}
    448          				else
    449          				{
    450          					mtCOVERAGE_TEST_MARKER();
    451          				}
    452          			}
    453          			taskEXIT_CRITICAL();
   \                     ??xEventGroupWaitBits_11: (+1)
   \       0xD8   0x....'....        BL       vPortExitCritical
    454          
    455          			/* Prevent compiler warnings when trace macros are not used. */
    456          			xTimeoutOccurred = pdFALSE;
   \       0xDC   0x2000             MOVS     R0,#+0
   \       0xDE   0x9000             STR      R0,[SP, #+0]
    457          		}
    458          		else
    459          		{
    460          			/* The task unblocked because the bits were set. */
    461          		}
    462          
    463          		/* The task blocked so control bits may have been set. */
    464          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   \                     ??xEventGroupWaitBits_10: (+1)
   \       0xE0   0x46DA             MOV      R10,R11
   \       0xE2   0xF02A 0x4A7F      BIC      R10,R10,#0xFF000000
    465          	}
    466          	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
    467          
    468          	return uxReturn;
   \                     ??xEventGroupWaitBits_8: (+1)
   \       0xE6   0x4650             MOV      R0,R10
   \       0xE8   0xB005             ADD      SP,SP,#+20
   \       0xEA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    469          }
    470          /*-----------------------------------------------------------*/
    471          

   \                                 In section .text, align 2, keep-with-next
    472          EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    473          {
   \                     xEventGroupClearBits: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    474          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   \        0x6   0x0026             MOVS     R6,R4
    475          EventBits_t uxReturn;
    476          
    477          	/* Check the user is not attempting to clear the bits used by the kernel
    478          	itself. */
    479          	configASSERT( xEventGroup );
    480          	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    481          
    482          	taskENTER_CRITICAL();
   \        0x8   0x....'....        BL       vPortEnterCritical
    483          	{
    484          		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
    485          
    486          		/* The value returned is the event group value prior to the bits being
    487          		cleared. */
    488          		uxReturn = pxEventBits->uxEventBits;
   \        0xC   0x6837             LDR      R7,[R6, #+0]
    489          
    490          		/* Clear the bits. */
    491          		pxEventBits->uxEventBits &= ~uxBitsToClear;
   \        0xE   0x6830             LDR      R0,[R6, #+0]
   \       0x10   0x43A8             BICS     R0,R0,R5
   \       0x12   0x6030             STR      R0,[R6, #+0]
    492          	}
    493          	taskEXIT_CRITICAL();
   \       0x14   0x....'....        BL       vPortExitCritical
    494          
    495          	return uxReturn;
   \       0x18   0x0038             MOVS     R0,R7
   \       0x1A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    496          }
    497          /*-----------------------------------------------------------*/
    498          
    499          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    500          
    501          	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    502          	{
    503          		BaseType_t xReturn;
    504          
    505          		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
    506          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL );
    507          
    508          		return xReturn;
    509          	}
    510          
    511          #endif
    512          /*-----------------------------------------------------------*/
    513          

   \                                 In section .text, align 2, keep-with-next
    514          EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
    515          {
   \                     xEventGroupGetBitsFromISR: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    516          UBaseType_t uxSavedInterruptStatus;
    517          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   \        0x2   0x000B             MOVS     R3,R1
    518          EventBits_t uxReturn;
    519          
    520          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \        0x4   0xF3EF 0x8211      MRS      R2,BASEPRI
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
    521          	{
    522          		uxReturn = pxEventBits->uxEventBits;
   \       0x16   0x6818             LDR      R0,[R3, #+0]
    523          	}
    524          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \       0x18   0xF382 0x8811      MSR      BASEPRI,R2
    525          
    526          	return uxReturn;
   \       0x1C   0x4770             BX       LR               ;; return
    527          }
    528          /*-----------------------------------------------------------*/
    529          

   \                                 In section .text, align 2, keep-with-next
    530          EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
    531          {
   \                     xEventGroupSetBits: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
    532          ListItem_t *pxListItem, *pxNext;
    533          ListItem_t const *pxListEnd;
    534          List_t *pxList;
    535          EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
   \        0x8   0xF05F 0x0B00      MOVS     R11,#+0
    536          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   \        0xC   0x46A9             MOV      R9,R5
    537          BaseType_t xMatchFound = pdFALSE;
   \        0xE   0x2400             MOVS     R4,#+0
    538          
    539          	/* Check the user is not attempting to set the bits used by the kernel
    540          	itself. */
    541          	configASSERT( xEventGroup );
    542          	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    543          
    544          	pxList = &( pxEventBits->xTasksWaitingForBits );
   \       0x10   0xF119 0x0004      ADDS     R0,R9,#+4
   \       0x14   0x9000             STR      R0,[SP, #+0]
    545          	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \       0x16   0x9800             LDR      R0,[SP, #+0]
   \       0x18   0x3008             ADDS     R0,R0,#+8
   \       0x1A   0x9002             STR      R0,[SP, #+8]
    546          	vTaskSuspendAll();
   \       0x1C   0x....'....        BL       vTaskSuspendAll
    547          	{
    548          		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
    549          
    550          		pxListItem = listGET_HEAD_ENTRY( pxList );
   \       0x20   0x9800             LDR      R0,[SP, #+0]
   \       0x22   0xF8D0 0xA00C      LDR      R10,[R0, #+12]
    551          
    552          		/* Set the bits. */
    553          		pxEventBits->uxEventBits |= uxBitsToSet;
   \       0x26   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x2A   0x4330             ORRS     R0,R6,R0
   \       0x2C   0xF8C9 0x0000      STR      R0,[R9, #+0]
    554          
    555          		/* See if the new bit value should unblock any tasks. */
    556          		while( pxListItem != pxListEnd )
   \                     ??xEventGroupSetBits_0: (+1)
   \       0x30   0x9802             LDR      R0,[SP, #+8]
   \       0x32   0x4582             CMP      R10,R0
   \       0x34   0xD02E             BEQ.N    ??xEventGroupSetBits_1
    557          		{
    558          			pxNext = listGET_NEXT( pxListItem );
   \       0x36   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x3A   0x9001             STR      R0,[SP, #+4]
    559          			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
   \       0x3C   0xF8DA 0x0000      LDR      R0,[R10, #+0]
    560          			xMatchFound = pdFALSE;
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0x000C             MOVS     R4,R1
    561          
    562          			/* Split the bits waited for from the control bits. */
    563          			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
   \       0x44   0xF010 0x417F      ANDS     R1,R0,#0xFF000000
   \       0x48   0x4688             MOV      R8,R1
    564          			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
   \       0x4A   0xF020 0x407F      BIC      R0,R0,#0xFF000000
   \       0x4E   0x0007             MOVS     R7,R0
    565          
    566          			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
   \       0x50   0xEA5F 0x1048      LSLS     R0,R8,#+5
   \       0x54   0xD406             BMI.N    ??xEventGroupSetBits_2
    567          			{
    568          				/* Just looking for single bit being set. */
    569          				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
   \       0x56   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x5A   0x4207             TST      R7,R0
   \       0x5C   0xD009             BEQ.N    ??xEventGroupSetBits_3
    570          				{
    571          					xMatchFound = pdTRUE;
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0x0004             MOVS     R4,R0
   \       0x62   0xE006             B.N      ??xEventGroupSetBits_3
    572          				}
    573          				else
    574          				{
    575          					mtCOVERAGE_TEST_MARKER();
    576          				}
    577          			}
    578          			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
   \                     ??xEventGroupSetBits_2: (+1)
   \       0x64   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x68   0x4038             ANDS     R0,R0,R7
   \       0x6A   0x42B8             CMP      R0,R7
   \       0x6C   0xD101             BNE.N    ??xEventGroupSetBits_3
    579          			{
    580          				/* All bits are set. */
    581          				xMatchFound = pdTRUE;
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0x0004             MOVS     R4,R0
    582          			}
    583          			else
    584          			{
    585          				/* Need all bits to be set, but not all the bits were set. */
    586          			}
    587          
    588          			if( xMatchFound != pdFALSE )
   \                     ??xEventGroupSetBits_3: (+1)
   \       0x72   0x2C00             CMP      R4,#+0
   \       0x74   0xD00B             BEQ.N    ??xEventGroupSetBits_4
    589          			{
    590          				/* The bits match.  Should the bits be cleared on exit? */
    591          				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
   \       0x76   0xEA5F 0x10C8      LSLS     R0,R8,#+7
   \       0x7A   0xD501             BPL.N    ??xEventGroupSetBits_5
    592          				{
    593          					uxBitsToClear |= uxBitsWaitedFor;
   \       0x7C   0xEA57 0x0B0B      ORRS     R11,R7,R11
    594          				}
    595          				else
    596          				{
    597          					mtCOVERAGE_TEST_MARKER();
    598          				}
    599          
    600          				/* Store the actual event flag value in the task's event list
    601          				item before removing the task from the event list.  The
    602          				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
    603          				that is was unblocked due to its required bits matching, rather
    604          				than because it timed out. */
    605          				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
   \                     ??xEventGroupSetBits_5: (+1)
   \       0x80   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0x84   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x88   0x4650             MOV      R0,R10
   \       0x8A   0x....'....        BL       xTaskRemoveFromUnorderedEventList
    606          			}
    607          
    608          			/* Move onto the next list item.  Note pxListItem->pxNext is not
    609          			used here as the list item may have been removed from the event list
    610          			and inserted into the ready/pending reading list. */
    611          			pxListItem = pxNext;
   \                     ??xEventGroupSetBits_4: (+1)
   \       0x8E   0x9801             LDR      R0,[SP, #+4]
   \       0x90   0x4682             MOV      R10,R0
   \       0x92   0xE7CD             B.N      ??xEventGroupSetBits_0
    612          		}
    613          
    614          		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
    615          		bit was set in the control word. */
    616          		pxEventBits->uxEventBits &= ~uxBitsToClear;
   \                     ??xEventGroupSetBits_1: (+1)
   \       0x94   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x98   0xEA30 0x000B      BICS     R0,R0,R11
   \       0x9C   0xF8C9 0x0000      STR      R0,[R9, #+0]
    617          	}
    618          	( void ) xTaskResumeAll();
   \       0xA0   0x....'....        BL       xTaskResumeAll
    619          
    620          	return pxEventBits->uxEventBits;
   \       0xA4   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xA8   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    621          }
    622          /*-----------------------------------------------------------*/
    623          

   \                                 In section .text, align 2, keep-with-next
    624          void vEventGroupDelete( EventGroupHandle_t xEventGroup )
    625          {
   \                     vEventGroupDelete: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    626          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
   \        0x4   0x0026             MOVS     R6,R4
    627          const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
   \        0x6   0x1D35             ADDS     R5,R6,#+4
    628          
    629          	vTaskSuspendAll();
   \        0x8   0x....'....        BL       vTaskSuspendAll
    630          	{
    631          		traceEVENT_GROUP_DELETE( xEventGroup );
    632          
    633          		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
   \                     ??vEventGroupDelete_0: (+1)
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD005             BEQ.N    ??vEventGroupDelete_1
    634          		{
    635          			/* Unblock the task, returning 0 as the event list is being deleted
    636          			and	cannot therefore have any bits set. */
    637          			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
    638          			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
   \       0x12   0xF05F 0x7100      MOVS     R1,#+33554432
   \       0x16   0x68E8             LDR      R0,[R5, #+12]
   \       0x18   0x....'....        BL       xTaskRemoveFromUnorderedEventList
   \       0x1C   0xE7F6             B.N      ??vEventGroupDelete_0
    639          		}
    640          
    641          		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    642          		{
    643          			/* The event group can only have been allocated dynamically - free
    644          			it again. */
    645          			vPortFree( pxEventBits );
    646          		}
    647          		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    648          		{
    649          			/* The event group could have been allocated statically or
    650          			dynamically, so check before attempting to free the memory. */
    651          			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
    652          			{
    653          				vPortFree( pxEventBits );
    654          			}
    655          			else
    656          			{
    657          				mtCOVERAGE_TEST_MARKER();
    658          			}
    659          		}
    660          		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    661          	}
    662          	( void ) xTaskResumeAll();
   \                     ??vEventGroupDelete_1: (+1)
   \       0x1E   0x....'....        BL       xTaskResumeAll
    663          }
   \       0x22   0xBD70             POP      {R4-R6,PC}       ;; return
    664          /*-----------------------------------------------------------*/
    665          
    666          /* For internal use only - execute a 'set bits' command that was pended from
    667          an interrupt. */

   \                                 In section .text, align 2, keep-with-next
    668          void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
    669          {
   \                     vEventGroupSetBitsCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    670          	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
   \        0x6   0x0029             MOVS     R1,R5
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x....'....        BL       xEventGroupSetBits
    671          }
   \        0xE   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    672          /*-----------------------------------------------------------*/
    673          
    674          /* For internal use only - execute a 'clear bits' command that was pended from
    675          an interrupt. */

   \                                 In section .text, align 2, keep-with-next
    676          void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
    677          {
   \                     vEventGroupClearBitsCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    678          	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
   \        0x6   0x0029             MOVS     R1,R5
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x....'....        BL       xEventGroupClearBits
    679          }
   \        0xE   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    680          /*-----------------------------------------------------------*/
    681          

   \                                 In section .text, align 2, keep-with-next
    682          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
    683          {
   \                     prvTestWaitCondition: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0003             MOVS     R3,R0
    684          BaseType_t xWaitConditionMet = pdFALSE;
   \        0x4   0x2000             MOVS     R0,#+0
    685          
    686          	if( xWaitForAllBits == pdFALSE )
   \        0x6   0x2A00             CMP      R2,#+0
   \        0x8   0xD104             BNE.N    ??prvTestWaitCondition_0
    687          	{
    688          		/* Task only has to wait for one bit within uxBitsToWaitFor to be
    689          		set.  Is one already set? */
    690          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
   \        0xA   0x420B             TST      R3,R1
   \        0xC   0xD008             BEQ.N    ??prvTestWaitCondition_1
    691          		{
    692          			xWaitConditionMet = pdTRUE;
   \        0xE   0x2401             MOVS     R4,#+1
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0xE005             B.N      ??prvTestWaitCondition_1
    693          		}
    694          		else
    695          		{
    696          			mtCOVERAGE_TEST_MARKER();
    697          		}
    698          	}
    699          	else
    700          	{
    701          		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
    702          		Are they set already? */
    703          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \                     ??prvTestWaitCondition_0: (+1)
   \       0x14   0xEA11 0x0403      ANDS     R4,R1,R3
   \       0x18   0x428C             CMP      R4,R1
   \       0x1A   0xD101             BNE.N    ??prvTestWaitCondition_1
    704          		{
    705          			xWaitConditionMet = pdTRUE;
   \       0x1C   0x2401             MOVS     R4,#+1
   \       0x1E   0x0020             MOVS     R0,R4
    706          		}
    707          		else
    708          		{
    709          			mtCOVERAGE_TEST_MARKER();
    710          		}
    711          	}
    712          
    713          	return xWaitConditionMet;
   \                     ??prvTestWaitCondition_1: (+1)
   \       0x20   0xBC10             POP      {R4}
   \       0x22   0x4770             BX       LR               ;; return
    714          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0xE000'ED04        DC32     0xe000ed04
    715          /*-----------------------------------------------------------*/
    716          
    717          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    718          
    719          	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
    720          	{
    721          	BaseType_t xReturn;
    722          
    723          		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
    724          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
    725          
    726          		return xReturn;
    727          	}
    728          
    729          #endif
    730          /*-----------------------------------------------------------*/
    731          
    732          #if (configUSE_TRACE_FACILITY == 1)
    733          
    734          	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
    735          	{
    736          	UBaseType_t xReturn;
    737          	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    738          
    739          		if( xEventGroup == NULL )
    740          		{
    741          			xReturn = 0;
    742          		}
    743          		else
    744          		{
    745          			xReturn = pxEventBits->uxEventGroupNumber;
    746          		}
    747          
    748          		return xReturn;
    749          	}
    750          
    751          #endif
    752          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   prvTestWaitCondition
      16   vEventGroupClearBitsCallback
        16   -> xEventGroupClearBits
      16   vEventGroupDelete
        16   -> vTaskSuspendAll
        16   -> xTaskRemoveFromUnorderedEventList
        16   -> xTaskResumeAll
      16   vEventGroupSetBitsCallback
        16   -> xEventGroupSetBits
      24   xEventGroupClearBits
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      16   xEventGroupCreateStatic
        16   -> vListInitialise
       0   xEventGroupGetBitsFromISR
      48   xEventGroupSetBits
        48   -> vTaskSuspendAll
        48   -> xTaskRemoveFromUnorderedEventList
        48   -> xTaskResumeAll
      48   xEventGroupSync
        48   -> uxTaskResetEventItemValue
        48   -> vPortEnterCritical
        48   -> vPortExitCritical
        48   -> vTaskPlaceOnUnorderedEventList
        48   -> vTaskSuspendAll
        48   -> xEventGroupSetBits
        48   -> xTaskGetSchedulerState
        48   -> xTaskResumeAll
      56   xEventGroupWaitBits
        56   -> prvTestWaitCondition
        56   -> uxTaskResetEventItemValue
        56   -> vPortEnterCritical
        56   -> vPortExitCritical
        56   -> vTaskPlaceOnUnorderedEventList
        56   -> vTaskSuspendAll
        56   -> xTaskGetSchedulerState
        56   -> xTaskResumeAll


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
      36  prvTestWaitCondition
      16  vEventGroupClearBitsCallback
      36  vEventGroupDelete
      16  vEventGroupSetBitsCallback
      28  xEventGroupClearBits
      24  xEventGroupCreateStatic
      30  xEventGroupGetBitsFromISR
     172  xEventGroupSetBits
     202  xEventGroupSync
     238  xEventGroupWaitBits

 
 802 bytes in section .text
 
 802 bytes of CODE memory

Errors: none
Warnings: 1
